---
title: GoGC指南
date: 2022-07-26 09:02:56
anthor: Zhang
tags: 
  - GC
  - Golang
---

# GO GC指南

## 导读

本指南旨在通过提供对Go垃圾回收器（GOGC）的见解，帮助对GO语言的高级用户更好地理解他们应用成本。它还可以指导GO语言的用户使用这些见解来改善应用程序的资源利用率。使用本指南不需要了解GC相关知识，但需要熟悉GO语言。



GO语言负责安排GO值的存储；在大多数情况下，GO开发人员不必关心这些值的存储位置及为什么要被这样存储。然而在实际情况中值通常需要存储在计算机的物理内存中，而物理内存作为有限的资源，所以必须仔细管理内存并进行回收，以避免执行GO程序时超出内存限制。GO的工作就是按需分配和回收内存。



自动回收内存的另一个术语是垃圾收集。在较高层次上讲，GC是一个系统，它识别并代表应用程序回收内存中不再被需要的部分。GO标准工具链提供了一个运行时库，该库与每个应用程序一起发货，此运行时库包括一个垃圾收集器。



请注意，GO规范并不能保证垃圾收集器的存在，只有GO值的基础存储是由语言本身管理的。这种遗漏是有意的，并且允许使用不同的内存管理技术。



因此，本指南是关于GO编程语言的特定实现，并且可能不适用于其他实现。具体而言，以下指南适用于标准工具链（GC GO编译器和工具）。GCCGO和GOLLVM都使用非常相似的GC实现，因此适用了许多相同的概念，但细节可能会有所不同。



此外，这是一个活生生的文件，会随着时间的推移而改变，以最好地反映GO的最新版本。本文档目前描述了GO 1.19的垃圾收集器。

### 值存储

在我们深入GC之前，让我们首先讨论不需要由GC管理的内存。



例如，存储在局部变量中的非指针GO值可能根本不会由GO GC管理，由GO进行内存分配，并将其绑定到创建它的词法作用域中。通常，这比依靠GC更有效，因为GO编译器能够预先确定何时释放该内存，并发出清理内存的指令。通常，我们将这种分配内存的方式称为“栈分配”，因为该内存空间存储在Goroutine的栈上。



如果Go语言的值不能以这种方式分配内存，则Go语言编译器无法确定它的生存期，那么这些值就被称为“**逃逸到堆**”。“堆”可以被认为是内存分配的一个大杂烩，Go语言的值需要被放置在堆的某个地方。在堆上分配内存的操作通常称为“动态内存分配”，因为编译器和运行库都很少会对如何使用内存以及何时可以清理内存做出假设。这就是GC的用武之地：它是一个专门标识和清理动态内存分配的系统。



Go语言的值需要逃逸到堆中的原因有很多。一个原因可能是其大小是动态确定的。例如，考虑一个切片的支持数组，它的初始大小由一个变量而不是一个常量确定。请注意，逃逸到堆也具有传递性：如果一个Go值的引用被写入到另一个已经被确定为逃逸的Go值中，那么这个值也必须逃逸。



Go语言的值是否逃逸取决于使用它的上下文和Go语言编译器的逃逸分析算法。当值逃逸时，试图准确地列举它将是脆弱和困难的：算法本身相当复杂，并且在不同的Go语言版本中会有所变化。有关如何识别哪些值逃逸而哪些值不逃逸的详细信息，请参阅消除堆分配一节。



### 追踪GC

垃圾回收可能指自动回收内存的众多实现方法，例如引用计数。在本文档的上下文中，GC指的是跟踪垃圾回收，其通过追寻指针来标识正在使用的、所谓的活动对象。



让我们更严格地定义这些术语:

- **对象** - 对象是一个动态分配的内存块，包含一个或多个Go值。

- **指针** - 指向对象内任何值的内存地址。这自然包括 `*T` 形式的Go语言值，但也包括部分内置Go语言值。字符串、切片、通道、map和接口值都包含GC必须跟踪的内存地址。

  

对象和指向其他对象的指针一起形成**对象图**。为了识别活动内存，GC从程序的**根**开始遍历对象图，程序明确使用的对象的指针。根的两个例子是局部变量和全局变量。遍历对象图的过程被称为**扫描**。



此基本算法对所有跟踪GC通用。跟踪GC的不同之处在于，一旦它们发现内存是活的后的处理。Go语言的GC使用了**标记(mark)—清除(sweep)技术，这意味着为了跟踪它的过程，GC也会将它遇到的值标记**为活动的。跟踪完成后，GC将遍历堆中的所有内存，并使所有未标记的对象的内存设置为可用于分配的内存。此过程称为**扫描(scanning)**。

您可能熟悉的另一种技术是将对象实际移动到内存的新部分，并留下一个转发指针，以后将使用该指针更新应用程序的所有指针。我们称以这种方式移动对象的GC为**移动GC**; Go的GC不是这样子的，它是**非移动GC**。



## GC循环

由于GO GC使用标记清除法，因此它分为两个阶段：标记阶段和清扫阶段。尽管这句话似乎重复，但它包含一个重要的见解：在追踪完所有内存之前，不可将内存释放以供分配。因为可能仍然有一个未扫描的指针使对象保持活跃状态。因此，清扫行为必须与标记行为完全分开。此外，如果没有与GC相关的工作，GC也可能根本不活跃。GC在关闭、标记、清扫三个状态下连续旋转，这就是所谓的GC循环。



接下来的几个章节我们将集中讨论如何直观地了解GC的成本，以帮助用户调整GC参数，从而为自己谋福利。



### 了解成本

GC本质上是一个构建在更复杂系统上的复杂软件。当试图理解GC并调整其行为时，很容易陷入细节的泥潭。本节旨在提供一个框架，用于说明Go GC的开销和调优参数。



开始讨论前，先了解基于四个简单公理的GC成本模型。

1. 在GC执行时，应用程序会暂停。

2. GC只涉及两种资源：CPU时间和物理内存。

3. GC的内存开销包括活动堆内存、标记阶段之前分配的新堆内存，以及元数据空间（即使与前两个的开销成比例，但相比之下元数据空间开销也很小）。

   > 注意：活动堆内存是由上一个GC周期确定为活动的内存，而新堆内存是在当前周期中分配的任何内存，在结束时可能是活动的，也可能不是活动的。

4. GC的CPU成本被建模为每个周期的固定成本，以及与活动堆的大小成比例的边际成本(marginal cost)。

   > 注意：从渐进的角度来说，清扫的伸缩性比标记和扫描要差，因为它的工作量与整个堆的大小成正比，包括被确定为非活动（即“死”）的内存。然而，在当前的实现中，清扫操作比标记和扫描快得多，因此在本讨论中可以忽略其相关成本。

这种模型简单而有效：它准确地对GC的主要成本进行了分类。然而，这个模型没有说明这些成本的规模，也没有说明它们是如何相互作用的。为了对此建模，考虑以下情况，我们称这种场景为**稳态**(steady-stat)。

- 应用程序分配新内存的速率（以字节/秒为单位）是恒定的。

  > 注意：重要的是要理解这个分配率与这个新内存是否是活动的完全无关。没有一个是活的，所有的都是活的，或者一部分是活的都有可能。(除此之外，一些旧的堆内存也可能死亡，因此，如果该内存是活动的，活动堆大小不一定会增长。） 更具体地说，假设有一个web服务为它处理的每个请求分配2 MiB的总堆内存。在请求过程中，2 MiB中最多有512 KiB在请求进行期间保持活动状态，当服务完成对请求的处理时，所有这些内存都会死亡。稳定的请求流（比如每秒100个请求）会产生200 MiB/s的分配率和50 MiB的峰值活动堆。

- 应用程序的对象图每次看起来都大致相同（对象的大小相似，指针的数量大致恒定，图的最大深度大致恒定）。另一种思考方式是GC的边际成本是恒定的。

  > 注意：稳态可能看起来是人为的，但它的确代表了应用程序在某个恒定工作负载下的行为。当然，在应用程序执行时，工作负载也可能发生变化，但通常应用程序行为看起来总体上像是一串稳定状态，中间穿插着一些瞬态行为。

  > 注意：稳定状态对活动堆没有任何假设。它可能会随着每个后续GC周期而增长，可能会缩小，也可能会保持不变。然而，试图在下面的解释中包含所有这些情况很无聊乏味，而且不是很有说明性，所以本指南将重点放在活动堆保持不变的示例上。GOGC一节会更详细地探讨了非常量活动堆的场景。

在活动堆大小不变的稳定状态下，只要GC在经过相同的时间后执行，每个GC周期在成本模型中看起来都是相同的。这是因为在固定的时间内，如果应用程序的分配速率是固定的，则将分配固定数量的新堆内存。因此，在活动堆大小和新堆内存保持不变的情况下，内存使用量将始终保持不变。而且因为活动堆的大小相同，所以边际GC CPU成本也相同，并且固定成本将以某个固定间隔发生。



现在考虑GC如果延迟，发生在稍后时间应该运行的点之后， 因此将分配更多的内存，但每个GC周期仍将导致相同的CPU开销。但是，在其他固定的时间窗口中，完成的GC周期会更少，从而降低了总体CPU成本。如果GC决定提前启动，则情况正好相反：将分配较少的内存并且将更频繁地引起CPU成本。

这种情况代表了GC可以在CPU时间和内存之间进行的基本权衡，由GC实际执行的频率来控制。换句话说，平衡点完全由GC的频率定义。



还有一个细节需要定义，那就是GC应该决定何时开始。注意，这直接设置了任何特定稳态下的GC频率，从而定义了平衡点。在Go语言中，决定GC何时启动是用户可以控制的主要参数。

### GOGC

GOGC是Go GC的一个调优参数，它通过控制GC频率直接反映了CPU时间和内存之间的平衡。更具体地说，GOGC设置GC的目标堆大小，或者在标记阶段完成之前应该分配的新内存量。GOGC被定义为GC需要完成的工作量的百分比开销。这项工作目前被定义为活动堆的大小加上GC roots的大小（以字节为单位）。



举个例子，假设一个Go语言程序，它有8 MiB的堆，1 MiB的goroutine栈，1 MiB的全局变量指针。如果GOGC值为100，则在下一次GC运行之前将分配的新内存量将为10 MiB，或10 MiB工作量的100%，总堆占用量为18 MiB。如果GOGC值为50，则它将为50%，即分配的新内存量为5 MiB。如果GOGC值为200，则为200%，即分配的新内存量20 MiB。

> 注意：GOGC可以更精确地描述为定义在下一个扫描阶段开始之前可以分配的新内存量。从技术上讲，这个记时对于本指南目前使用的GC模型来说是正确的，但是它也适用于Go语言使用的真实GC实现，在延迟一节中会有更详细的讨论。



以这种方式定义权衡(trade-off)的好处是，无论GC必须完成的工作量如何（也就是说，无论活动堆和根集的大小如何），GC的成本在稳态下都保持不变，因为频率总是与必须完成的工作量成比例。换句话说，它代表了CPU成本和内存使用之间权衡的一个固定点。(需要注意的是，如果稳定状态也发生变化，则此固定点也可能发生偏移，但关键是它不依赖于活动堆的大小。）

> 注意：GOGC 自Go 1.18开始包含根集， 以前它只对活动堆进行计数。通常，goroutine堆栈中的内存量非常小，并且活动堆的大小支配着GC的所有其他工作来源, (所以先前的计算大概也没问题,) 但是当程序有几十万个goroutine时，GC会做出错误的判断。



GOGC可以通过GOGC环境变量（所有Go语言程序都能识别）或者`runtime/debug`包中的`SetGCPercent` API来配置。

> 请注意，GOGC也可用于通过设置`GOGC=off`或调用`SetGCPercent(-1)`来完全关闭GC（前提是memory limit没有使用）。从概念上讲，此设置等效于将GOGC设置为无穷大值，因为在触发GC之前新内存的数量是无限的。



为了更好地理解我们到目前为止讨论的所有内容，请尝试下面的交互式可视化，它是基于前面讨论的GC成本模型构建的。该可视化描述了某个程序的执行，该程序的非GC工作需要10秒的CPU时间才能完成。在进入稳定状态之前的第一秒，它执行一些初始化步骤（增长其活动堆）。应用程序总共分配200 MiB，其中20 MiB一次处于活动状态。它假设要完成的唯一相关GC工作来自活动堆，并且（不现实地）应用程序不使用额外的内存。



使用滑块调整GOGC的值，以查看应用程序在总持续时间和GC开销方面的响应情况。每次GC循环都会在新堆降为零时发生。X轴移动以始终显示程序的完整CPU持续时间。请注意，GC使用的额外CPU时间会增加总持续时间。



![](https://raw.githubusercontent.com/CrazyKFC/Wiki_Image/master/GOGC1.png)



请注意，GC总是会导致一些CPU和峰值内存开销。随着GOGC的增加，这些CPU开销降低，但峰值内存与活动堆大小成比例增加。随着GOGC的减小，峰值内存需求也会减少，但会增加额外的CPU开销。



> 注意：图形显示的是CPU时间，而不是完成程序所需的挂钟时间(wall-clock time)。如果程序在1个CPU上运行并充分利用其资源，则它们是等效的。真实的的程序可能运行在多核系统上，并且不会始终100%地利用CPU。在这些情况下，GC的挂钟时间影响会比较低。

> 注意：Go GC的最小总堆大小为4 MiB，因此如果GOGC设置的目标值低于该值，则会取整。这个图形展示反映此细节。



这里有一个动态的和更有真实感的例子。同样，在没有GC的情况下，应用程序需要10个CPU秒才能完成，但在中途，稳态分配率急剧增加，并且活动堆大小在第一阶段发生了一些变化。这个示例演示了当活动堆大小实际上发生变化时，稳定状态可能是什么样子的，以及更高的分配率如何导致更频繁的GC周期。



![](https://raw.githubusercontent.com/CrazyKFC/Wiki_Image/master/GOGC2.png)

### 内存限制

在Go 1.19之前，GOGC是唯一一个可以用来修改GC行为的参数。虽然这种设置平衡点的方式非常有效，但它没有考虑到可用内存是有限的。考虑当活动堆大小出现短暂峰值时会发生什么情况：因为GC将选择与活动堆大小成比例的总堆大小，所以GOGC必须被配置为峰值活动堆大小相匹配的值，即使在通常情况下，较高的GOGC值会提供了更好的权衡效果。



下面的可视化演示了这种瞬态堆峰值情况。



![](https://raw.githubusercontent.com/CrazyKFC/Wiki_Image/master/GOGC3.png)



如果示例工作负载在可用内存略高于60 MiB的容器中运行，则GOGC不能增加到100以上，即使其余GC周期有可用内存来使用该额外内存。此外，在一些应用中，这些瞬时峰值可能是罕见的并且难以预测，从而导致偶然的、不可避免的并且可能代价高昂的内存不足情况。



这就是为什么在1.19版本中，Go语言增加了对设置运行时内存限制的支持。内存限制可以通过所有Go语言程序都能识别的**GOMEMLIMIT**环境变量来配置，也可以通过`runtime/debug`包中的`SetMemoryLimit`函数来配置。



这个内存限制设置了Go语言运行时可以使用的最大内存总量。包含的特定内存集是`runtime.MemStats`的`Sys - HeapReleased`的值，或者等价于`runtime/metrics`的公式`/memory/classes/total:bytes - /memory/classes/heap/released:bytes`。



因为Go GC可以显式控制它使用多少堆内存，所以它会根据这个内存限制和Go运行时使用的其他内存来设置总的堆大小。



下面的可视化描述了来自GOGC部分的相同的单阶段稳态工作负载，但这次Go运行时额外增加了10 MiB的开销，并且内存限制可调。尝试在GOGC和内存限制之间移动，看看会发生什么。



![](https://raw.githubusercontent.com/CrazyKFC/Wiki_Image/master/GOGC4.png)



请注意，当内存限制降低到GOGC确定的峰值内存（GOGC为100时为42 MiB）以下时，GC会更频繁地运行，以将峰值内存保持在限制的内存之下。



回到我们前面的瞬态堆峰值的例子，通过设置内存限制并打开GOGC，我们可以获得两个世界的最佳结果：不违反内存限制，且更好地节约资源。请尝试以下交互式可视化。



![](https://raw.githubusercontent.com/CrazyKFC/Wiki_Image/master/GOGC5.png)



请注意，对于GOGC的某些值和内存限制，峰值内存使用在内存限制为多少时停止，但程序执行的其余部分仍然遵守GOGC设置的总堆大小规则。



这一观察引出了另一个有趣的细节：即使GOGC设置为关闭，内存限制仍然有效! 实际上，这种特定的配置代表了资源经济的最大化，因为它设置了维持某个内存限制所需的最小GC频率。在这种情况下，所有程序的执行都会使堆大小增加以满足内存限制。



现在，虽然内存限制显然是一个强大的工具，**但使用内存限制并不是没有代价的**，当然也不会使GOGC的实用性失效。



请考虑当活动堆增长到足以使总内存使用量接近内存限制时会发生什么。在上面的稳定状态可视化中，尝试关闭GOGC，然后慢慢地进一步降低内存限制，看看会发生什么。请注意，应用程序花费的总时间将开始以无限制的方式增长，因为GC不断地执行以维持不可能的内存限制。



这种情况，即程序由于不断的GC循环而无法取得合理的进展，称为系统颠簸(thrashing)。这是特别危险的，因为它严重地拖延了程序。更糟糕的是，它可能会发生在我们试图避免使用GOGC的情况下：一个足够大临时堆尖峰会导致程序无限期地停止! 尝试在瞬态堆峰值可视化中降低内存限制（大约30 MiB或更低），并注意最坏的行为是如何从堆峰值开始的。



在许多情况下，无限期暂停比内存不足情况更糟，因为后者往往会导致更快的失败以便我们发现和处理。



因此，内存限制被定义为软限制。Go语言运行时并不保证在任何情况下都能保持这个内存限制;它只承诺了一些合理的努力。内存限制的放宽对于避免系统颠簸行为至关重要，因为它为GC提供了一条出路：让内存使用超过限制以避免在GC中花费太多时间。



这在内部是如何工作的？GC mitigates 设置了一个在某个时间窗口内可以使用的CPU时间量的上限（对于CPU使用中非常短的瞬时峰值，有一些滞后）。此限制当前设置为大约50%，具有`2 * GOMAXPROCS CPU-second`窗口。限制GC CPU时间的结果是GC的工作被延迟，同时Go程序可能会继续分配新的堆内存，甚至超过内存限制。



50% GC CPU限制背后的直觉是基于对具有充足可用内存的程序的最坏情况影响。在内存限制配置错误的情况下，它被错误地设置得太低，程序最多会慢2倍，因为GC占用的CPU时间不能超过50%。



#### 建议用法

虽然内存限制是一个强大的工具，Go语言运行时也会采取措施来减少误用造成的最坏行为，但谨慎使用它仍然很重要。下面是一些关于内存限制在哪些地方最有用，以及在哪些地方可能弊大于利的建议。



- 当Go语言程序的执行环境完全在你的控制之下，并且Go语言程序是唯一可以访问某些资源的程序时（也就是说，某种内存预留，就像容器内存限制一样），一定要利用内存限制。一个很好的示例是将web服务部署到具有固定可用内存量的容器中。**在这种情况下，一个很好的经验法则是，留出额外的5-10%的空间来处理Go语言运行时不知道的内存资源。**
- 请随时调整内存限制，以适应不断变化的条件。一个很好的例子是cgo程序，其中C库暂时需要使用更多的内存。
- 如果Go语言程序可能会与其他程序共享有限的内存，那么不要将GOGC设置为off，因为这些程序通常与Go语言程序是解耦的。相反，保留内存限制，因为它可能有助于抑制不需要的瞬态行为，但将GOGC设置为某个较小的、对于一般情况而言合理的值。